from __future__ import annotations

import numpy as np
import xarray as xr


def get_low_cloud_fraction(cl: xr.DataArray, overlap_assumption: str = "maxrandom") -> xr.DataArray:
    return _get_cloud_fraction(cl, 1200, 700, overlap_assumption)


def get_medium_cloud_fraction(
    cl: xr.DataArray, overlap_assumption: str = "maxrandom"
) -> xr.DataArray:
    return _get_cloud_fraction(cl, 700, 400, overlap_assumption)


def get_high_cloud_fraction(
    cl: xr.DataArray, overlap_assumption: str = "maxrandom"
) -> xr.DataArray:
    return _get_cloud_fraction(cl, 400, 50, overlap_assumption)


def get_total_cloud_fraction(
    cl: xr.DataArray, overlap_assumption: str = "maxrandom"
) -> xr.DataArray:
    return _get_cloud_fraction(cl, 1200, 50, overlap_assumption)


def _get_cloud_fraction(
    cl: xr.DataArray, lower_plev: float, upper_plev: float, overlap_assumption: str
) -> xr.DataArray:
    cl = cl.sortby("lev", ascending=False).sel(lev=slice(lower_plev * 1e2, upper_plev * 1e2))
    match overlap_assumption:
        case "max":
            return cl.max("lev").fillna(0)
        case "min":
            return np.minimum(1, cl.sum("lev"))
        case "random":
            # Räisänen (1998), Eq. 3
            # Identical to C = Ci + Cj - Ci*Cj
            return 1 - (1 - cl).prod("lev")
        case "maxrandom":
            return xr.apply_ufunc(
                _max_random_overlap,
                cl,
                input_core_dims=[["lev"]],
                vectorize=True,
                dask="parallelized",
            )
        case _:
            raise ValueError(f"Unknown overlap assumption {overlap_assumption}")


def _max_random_overlap(profile):
    """
    Generated by Gemini

    Calculates the total cloud cover from a vertical profile of cloud fractions
    using the maximum-random overlap assumption.

    Args:
        profile (np.ndarray): A 1D array of cloud fractions, ordered
                              vertically. Values should be between 0 and 1.

    Returns:
        float: The total cloud fraction for the column.
    """
    total_cloud_cover = 0.0
    current_block_max = 0.0

    # Iterate through the cloud fraction of each layer in the profile
    for c_layer in profile:
        if c_layer > 0:
            # This layer is part of the current cloudy block.
            # Update the maximum cloud fraction for this block.
            current_block_max = max(current_block_max, c_layer)
        elif current_block_max > 0:
            # This is a clear layer, so the previous cloudy block has ended.
            # Combine the finished block with the total cloud cover so far.
            total_cloud_cover = (
                total_cloud_cover + current_block_max - total_cloud_cover * current_block_max
            )
            # Reset for the next potential block.
            current_block_max = 0.0

    # After the loop, check if the profile ended on a cloudy block.
    # If so, combine this last block.
    if current_block_max > 0:
        total_cloud_cover = (
            total_cloud_cover + current_block_max - total_cloud_cover * current_block_max
        )

    return total_cloud_cover


def calculate_cam6_cldovrlap(ncol, pint, cld):
    """
    Partitions each column into regions with clouds in neighboring layers.
    This information is used to implement maximum overlap in these regions
    with random overlap between them.

    ChatGPT translation of https://github.com/ESCOMP/CAM/blob/cam_cesm2_1_rel/src/physics/cam/pkg_cldoptics.F90#L136

    Parameters:
    ncol (int): Number of atmospheric columns
    pint (ndarray): Interface pressure, shape (ncol, pverp)
    cld (ndarray): Fractional cloud cover, shape (ncol, pver)

    Returns:
    nmxrgn (ndarray): Number of maximally overlapped regions, shape (ncol,)
    pmxrgn (ndarray): Interface pressures for lower boundaries of each region, shape (ncol, pverp)
    """
    import numpy as np

    pver = cld.shape[1]
    pverp = pint.shape[1]
    nmxrgn = np.zeros(ncol, dtype=int)
    pmxrgn = np.zeros((ncol, pverp))
    pnm = pint * 10.0  # Adjust units if necessary

    for i in range(ncol):
        cld_found = False
        cld_layer = cld[i, :] > 0.0
        n = 0
        for k in range(pver):
            if cld_layer[k] and not cld_found:
                cld_found = True
            elif not cld_layer[k] and cld_found:
                cld_found = False
                if not cld_layer[k:].any():
                    break
                pmxrgn[i, n] = pnm[i, k]
                n += 1
        pmxrgn[i, n] = pnm[i, -1]
        nmxrgn[i] = n + 1

    return nmxrgn, pmxrgn


def calculate_cam6_cldsav(ncol, cld, pmid, nmxrgn, pmxrgn):
    """
    Compute total and 3 levels of cloud fraction assuming maximum-random overlap.

    ChatGPT translation of https://github.com/ESCOMP/CAM/blob/cam_cesm2_1_rel/src/physics/cam/cloud_cover_diags.F90#L78

    Checked that this gives the same result as _max_random_overlap

    Parameters:
    ncol (int): Number of atmospheric columns
    cld (ndarray): Cloud fraction, shape (ncol, pver)
    pmid (ndarray): Level pressures, shape (ncol, pver)
    nmxrgn (ndarray): Number of maximally overlapped regions, shape (ncol,)
    pmxrgn (ndarray): Maximum pressures for each maximally overlapped region, shape (ncol, pverp)

    Returns:
    cldtot (ndarray): Total random overlap cloud cover, shape (ncol,)
    cldlow (ndarray): Low-level cloud cover, shape (ncol,)
    cldmed (ndarray): Middle-level cloud cover, shape (ncol,)
    cldhgh (ndarray): High-level cloud cover, shape (ncol,)
    """
    # Parameters
    plowmax = 120000.0
    plowmin = 70000.0
    pmedmax = 70000.0
    pmedmin = 40000.0
    phghmax = 40000.0
    phghmin = 5000.0

    ptypmin = np.array([phghmin, plowmin, pmedmin, phghmin])
    ptypmax = np.array([plowmax, plowmax, pmedmax, phghmax])

    max_nmxrgn = np.max(nmxrgn)

    cldtot = np.zeros(ncol)
    cldlow = np.zeros(ncol)
    cldmed = np.zeros(ncol)
    cldhgh = np.zeros(ncol)

    for ityp in range(4):
        irgn = np.zeros(ncol, dtype=int)
        for _ in range(int(max_nmxrgn) - 1):
            mask = (pmxrgn[np.arange(ncol), irgn] < ptypmin[ityp]) & (irgn < nmxrgn - 1)
            irgn += mask.astype(int)

        clrsky = np.ones(ncol)
        clrskymax = np.ones(ncol)
        pver = cld.shape[1]

        for k in range(pver):
            mask_level = (pmid[:, k] >= ptypmin[ityp]) & (pmid[:, k] <= ptypmax[ityp])
            mask_region = (pmxrgn[np.arange(ncol), irgn] < pmid[:, k]) & (irgn < nmxrgn - 1)
            update_irgn = mask_level & mask_region
            clrsky[update_irgn] *= clrskymax[update_irgn]
            clrskymax[update_irgn] = 1.0
            irgn[update_irgn] += 1
            clrskymax[mask_level] = np.minimum(clrskymax[mask_level], 1.0 - cld[mask_level, k])

        cloud_cover = 1.0 - (clrsky * clrskymax)
        if ityp == 0:
            cldtot = cloud_cover
        elif ityp == 1:
            cldlow = cloud_cover
        elif ityp == 2:
            cldmed = cloud_cover
        elif ityp == 3:
            cldhgh = cloud_cover

    return cldtot, cldlow, cldmed, cldhgh
